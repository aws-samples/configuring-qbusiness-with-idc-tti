# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0

# pylint: disable=invalid-name,not-an-iterable,missing-function-docstring,logging-fstring-interpolation

"""Create a custom data source"""

import os
import logging
import hashlib
from pathlib import Path

from dotenv import dotenv_values
from rich.logging import RichHandler
from rich.pretty import pretty_repr
from qbapi_tools.api_helpers import QBusinessAPIHelpers
from qbapi_tools.datamodel import (
    ServiceConfig, CreateDataSourceResponse
)

logger = logging.getLogger("qbapi_samples")
logger.addHandler(RichHandler(
    show_time=False, show_path=False, show_level=False, rich_tracebacks=False
))
logger.setLevel(logging.getLevelName(os.environ.get('logging', 'DEBUG')))

config = {
    **dotenv_values(dotenv_path=Path('./samples/.env').absolute())
}

DATA_BLOB = """
Why use trusted identity propagation?
Trusted identity propagation provides a mechanism that enables applications that authenticate outside of AWS to make requests on behalf of their users with the use of a trusted token issuer. Consider a client-server application that uses an external identity provider (IdP) to authenticate a user to provide access to an AWS resource that’s private to the user. For example, your web application might use Okta as an external IdP to authenticate a user to view their private conversations from Q Business. In this scenario, Q Business is unable to use the identity token generated by the third party provider to provide direct access to the user’s private data since there is no mechanism to trust the identity token issued by the third party.

To solve this, you can use IAM Identity Center to get the user identity from your external IdP into an AWS Identity and Access Management (IAM) role session which allows you to authorize requests based on the human, their attributes, and their group memberships, rather than set up fine-grained permissions in an IAM policy. You can exchange the token issued by the external IdP for a token generated by Identity Center. The token generated by Identity Center refers to the corresponding Identity Center user. The web application can now use the new token to initiate a request to Q Business for the private chat conversation. That token refers to the corresponding user in Identity Center, Q Business can authorize the requested access to the private conversation based on the user or their group membership as represented in Identity Center.

Some of the benefits of using trusted identity propagation are:
* Prevents user impersonation and protects against unauthorized access to user private data by spoofing user identity.
* Facilitates auditability and fosters responsible use of resources as Q Business automatically logs API invocations to AWS CloudTrail along with user identifier.
* Promotes software design principles rooted in user privacy.
"""
DATA_BLOB_SRC = "https://aws.amazon.com/blogs/machine-learning/configuring-amazon-q-business-with-aws-iam-identity-center-trusted-identity-propagation/"


def create_custom_ds(
        app_id: str,
        index_id: str,
        region_name: str,
        name: str) -> CreateDataSourceResponse:
    """Create a custom data source"""
    logger.info(
        "\n[bold][u]Use Case: Create a custom data source[/]",
        extra={"markup": True}
    )
    logger.debug(f"Region Name: {region_name}")
    logger.debug(f"Application ID: {app_id}")
    logger.debug(f"Index ID: {index_id}")

    q_api_helper = QBusinessAPIHelpers(
        service_config=ServiceConfig(region_name=region_name)
    )
    return q_api_helper.create_custom_ds(
        app_id=app_id,
        index_id=index_id,
        name=name
    )


def delete_custom_ds(app_id: str, index_id: str, custom_ds_id: str, region_name: str):
    """Delete custom data source"""
    logger.info(
        "\n[bold][u]Use Case: Delete custom data source[/]",
        extra={"markup": True}
    )
    logger.debug(f"Region Name: {region_name}")
    logger.debug(f"Application ID: {app_id}")
    logger.debug(f"Index ID: {index_id}")
    logger.debug(f"Custom DS ID: {custom_ds_id}")

    q_api_helper = QBusinessAPIHelpers(
        service_config=ServiceConfig(region_name=region_name)
    )
    return q_api_helper.delete_ds(
        app_id=app_id,
        index_id=index_id,
        ds_id=custom_ds_id
    )


def custom_ds_sync_data(
        app_id: str, index_id: str, custom_ds_id: str,
        user_id: str, acl_on: bool, region_name: str):
    """sync data with custom data source"""
    logger.info(
        "\n[bold][u]Use Case: Sync data with custom data source[/]",
        extra={"markup": True}
    )
    logger.debug(f"Region Name: {region_name}")
    logger.debug(f"Application ID: {app_id}")
    logger.debug(f"Index ID: {index_id}")
    logger.debug(f"Custom Data Source ID: {custom_ds_id}")
    logger.debug(f"ACL On: {acl_on}")
    logger.debug(f"User Id: {user_id}")
    q_api_helper = QBusinessAPIHelpers(
        service_config=ServiceConfig(region_name=region_name)
    )

    # When using ACL, First add user alias to Q Business User Store
    if acl_on:
        add_user_resp = q_api_helper.add_user_alias(
            user_id, user_id, app_id, 
            index_id, custom_ds_id
        )
        logger.debug(f"Add user to store:\n{add_user_resp}")

    # Start sync and add document with ACL
    sync_start_resp = q_api_helper.start_ds_sync_job(app_id, index_id, custom_ds_id)
    logger.debug(f"Sync job start:\n{sync_start_resp}")
    try:
        document = {
            "id": hashlib.shake_256(DATA_BLOB_SRC.encode('utf-8')).hexdigest(128),
            "attributes": [{
                "name": "_source_uri",
                "value": {"stringValue": DATA_BLOB_SRC}
            }],
            "content": {"blob": DATA_BLOB.encode('utf-8')},
            "contentType": "PLAIN_TEXT",
            "title": "Why use trusted identity propagation?"
        }
        if acl_on:
            document["accessConfiguration"] = {
                'accessControls': [
                    {
                        'principals': [
                            {
                                'user': {
                                    'id': user_id,
                                    'access': 'ALLOW',
                                    'membershipType': 'DATASOURCE'
                                }
                            }
                        ]
                    },
                ]
            }
        resp = q_api_helper.put_documents(
            app_id, index_id,
            sync_start_resp.executionId,
            [document]
        )
        logger.debug(f"Put document: {pretty_repr(resp)}")
    except Exception as ex:
        logger.exception(ex)
    q_api_helper.stop_ds_sync_job(app_id, index_id, custom_ds_id)


def main():
    """Demonstrate custom data source"""

    # **********************************************************
    # * Update env file for                                    *
    # * - AWS Region name                                      *
    # * - Q Business app id                                    *
    # * - Q Business index id                                  *
    # * - Q Business custom data source id                     *
    # * - Create/delete custom data source flag                *
    # **********************************************************

    region_name = config.get(
        "region_name",
        os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
    )
    acl_on = config.get("acl_on", "false").lower() == "true"
    create_ds = config.get("create_custom_ds", "false").lower() == "true"
    delete_ds = config.get("delete_custom_ds", "false").lower() == "true"
    user_id = config.get("user_id", "tester@anycompany.com")

    app_id = config.get("app_id")
    if not app_id:
        raise ValueError("Missing Q Business application app_id.")
    index_id = config.get("index_id")
    if not index_id:
        raise ValueError("Missing index_id.")

    custom_ds_id = config.get("custom_ds_id")
    if create_ds:
        # Create new custom data source
        resp = create_custom_ds(app_id, index_id, region_name, "demo-custom-ds")
        logger.debug("Create data source:\n{resp}")
        custom_ds_id = resp.dataSourceId
    elif delete_ds:
        # Delete custom data source
        delete_custom_ds(app_id, index_id, custom_ds_id, region_name)
    elif custom_ds_id:
        # sync data
        custom_ds_sync_data(app_id, index_id, custom_ds_id, user_id, acl_on, region_name)
    else:
        raise ValueError("Missing custom_ds_id.")

if __name__ == "__main__":
    main()
